from pyproj import Transformer
from pyproj import CRS
import numpy as np
import overpy
import pickle

class DistanceToRoad():
    def download(self,x0,y0,x1,y1,crs_proj,spacing=50,margin=0.1,refreshcache=False):
        crs_4326 = CRS("WGS84")
        self.crs_proj = crs_proj
        transformer = Transformer.from_crs(crs_4326, crs_proj)
        self.box = np.c_[transformer.transform([x0,x1],[y0,y1])]
        self.spacing = spacing
        self.cachename = 'dtrcache_%0.8f_%0.8f_%0.8f_%0.8f_%s_%0.8f_%0.8f.p' % (x0,y0,x1,y1,str(crs_proj),spacing,margin)
        if not refreshcache:
            try:
                cache_data = pickle.load(open(self.cachename,'rb'))
                self.distancegrid = cache_data['distancegrid']
                print("Cache hit")
                return
            except FileNotFoundError:
                refreshcache = True
        if refreshcache:
            print("Cache miss")
            api = overpy.Overpass()
            #self.box = [x0,y0,x1,y1]
            api_query_string = """
            /*This has been generated by the overpass-turbo wizard.*/
            [out:json][timeout:25];
            (
              way["highway"="tertiary"]({x0},{y0},{x1},{y1});
              way["highway"="primary"]({x0},{y0},{x1},{y1});
              way["highway"="secondary"]({x0},{y0},{x1},{y1});
              way["highway"="trunk"]({x0},{y0},{x1},{y1});
              way["highway"="motorway"]({x0},{y0},{x1},{y1}); 
            );
            out body;
            >;
            out skel qt;
            """.format(x0=x0-margin,y0=y0-margin,x1=x1+margin,y1=y1+margin)
            self.api_query_result = api.query(api_query_string)
            #proj = pyproj.Proj(init='epsg:3857') #EPSG:3857 -- WGS84 Web Mercator [used by websites]
            
            self.converted_ways = []
            
            for way in self.api_query_result.ways:
            #    wgs84 = pyproj.Proj(init='EPSG:4326') #WGS 84 [used by GPS satellite system]
            #    self.converted_ways.append(np.c_[pyproj.transform(wgs84,proj,path[:,0],path[:,1])])

                path = np.array([[float(n.lat),float(n.lon)] for n in way.nodes])
                self.converted_ways.append(np.c_[transformer.transform(path[:,0],path[:,1])])
            
            self.compute_cacheboxes()
            self.compute_distancegrid()
    
    def lineseg_dists(self, p, a, b):
        """Cartesian distance from point to line segment
        From:
        https://stackoverflow.com/a/54442561/11208892        

        Args:
            - p: np.array of single point, shape (2,) or 2D array, shape (x, 2)
            - a: np.array of shape (x, 2)
            - b: np.array of shape (x, 2)
        """
        # normalized tangent vectors
        d_ba = b - a
        d = np.divide(d_ba, (np.hypot(d_ba[:, 0], d_ba[:, 1])
                               .reshape(-1, 1)))

        # signed parallel distance components
        # rowwise dot products of 2D vectors
        s = np.multiply(a - p, d).sum(axis=1)
        t = np.multiply(p - b, d).sum(axis=1)

        # clamped parallel distance
        h = np.maximum.reduce([s, t, np.zeros(len(s))])

        # perpendicular distance component
        # rowwise cross products of 2D vectors  
        d_pa = p - a
        c = d_pa[:, 0] * d[:, 1] - d_pa[:, 1] * d[:, 0]

        return np.hypot(h, c)   
    
    def compute_cacheboxes(self):
        self.cachedboxes = []
        for path in self.converted_ways:
            mina,maxa = np.min(path,0),np.max(path,0)
            self.cachedboxes.append(np.array([mina,np.array([mina[0],maxa[1]]),maxa,np.array([maxa[0],mina[1]]),mina]))

    def compute_mindist(self,p):
        mindists = []
        maxdists = []
        for box in self.cachedboxes:
            mindists.append(np.min(self.lineseg_dists(p,box[:-1,:],box[1:,:])**2))
            maxdists.append(np.max(np.sum((p-box[:-1,:])**2,1)))

        check = mindists<np.min(maxdists)
        mindist = np.inf
        for c,path in zip(check,self.converted_ways):
        #for path in self.converted_ways:
            if not c: continue 
            d = np.min(self.lineseg_dists(p,path[0:-1,:],path[1:,:]))
            if d<mindist:
                mindist=d
        return mindist  
    
    def compute_distancegrid(self):
        
        xs = np.arange(self.box[0,0],self.box[1,0],self.spacing)
        ys = np.arange(self.box[0,1],self.box[1,1],self.spacing)
        distancegrid = np.zeros([len(xs),len(ys)])
        #allps = []
        #allds = []
        for xi,x in enumerate(xs):
            print("%4d%%" % (int(100*(xi+1)/len(xs))),end="\r")
            for yi,y in enumerate(ys):
                #allps.append([x,y])
                #allds.append(dtr.compute_mindist([x,y]))
                distancegrid[xi,yi] = dtr.compute_mindist([x,y])
        import pickle
        pickle.dump({'distancegrid':distancegrid,'spacing':self.spacing,'box':self.box},open(self.cachename,'wb'))
        self.distancegrid = distancegrid
    
    def get_dist(self,p):
        index = ((p-self.box[0,:])/self.spacing).astype(int)
        ratio = ((p-self.box[0,:]) % self.spacing)/self.spacing
        #return (self.distancegrid[index[0]+1,index[1]]*ratio[0]+self.distancegrid[index[0],index[1]]*(1-ratio[0]))*(1-ratio[1])+self.distancegrid[index[0]+1,index[1]+1]*ratio[0]+self.distancegrid[index[0],index[1]+1]*(1-ratio[0])*(ratio[1])
        try:
            a0 = self.distancegrid[index[0]+1,index[1]]*ratio[0]
            a1 = self.distancegrid[index[0],index[1]]*(1-ratio[0])
            a = (a0+a1)*(1-ratio[1])
            b0 = self.distancegrid[index[0]+1,index[1]+1]*ratio[0]
            b1 = self.distancegrid[index[0],index[1]+1]*(1-ratio[0])
            b = (b0+b1)*(ratio[1])
            return a+b
        except IndexError:
            return np.nan
