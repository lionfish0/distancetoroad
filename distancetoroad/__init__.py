from pyproj import Transformer
from pyproj import CRS
import numpy as np
import overpy
import pickle

class DistanceToRoad():
    def download(self,x0,y0,x1,y1,crs_proj,spacing=50,margin=0.01,refreshcache=False):
        """
        Downloads the OSM map data from the overpass API, computes a grid of road distances and caches it.
        x0,y0,x1,y1 = the bounding box of the grid
        crs_proj = the coordinate system appropriate for the location to convert the lat/long to (for computing distances). Hopefully one in metres easting/northing.
        spacing = distance between grid points.
        margin = degrees of lat/long to add around the edge of the box, to try and ensure we get the true distance to roads that are not necessarily in the box.
        refreshcache = whether to force the system to download the data again and rebuild. 
        """
        crs_4326 = CRS("WGS84")
        self.crs_proj = crs_proj
        transformer = Transformer.from_crs(crs_4326, crs_proj)
        self.box = np.c_[transformer.transform([x0,x1],[y0,y1])]
        self.spacing = spacing
        self.cachename = 'dtrcache_%0.8f_%0.8f_%0.8f_%0.8f_%s_%0.8f_%0.8f.p' % (x0,y0,x1,y1,str(crs_proj),spacing,margin)
        if not refreshcache:
            try:
                cache_data = pickle.load(open(self.cachename,'rb'))
                self.distancegrid = cache_data['distancegrid']
                self.converted_ways = cache_data['converted_ways']
                print("Using cached data.")
                return
            except FileNotFoundError:
                refreshcache = True
        if refreshcache:
            print("Cache not found. Downloading from OSM Overpass...")
            api = overpy.Overpass()
            #self.box = [x0,y0,x1,y1]
            api_query_string = """
            /*This has been generated by the overpass-turbo wizard.*/
            [out:json][timeout:25];
            (
              way["highway"="tertiary"]({x0},{y0},{x1},{y1});
              way["highway"="primary"]({x0},{y0},{x1},{y1});
              way["highway"="secondary"]({x0},{y0},{x1},{y1});
              way["highway"="trunk"]({x0},{y0},{x1},{y1});
              way["highway"="motorway"]({x0},{y0},{x1},{y1}); 
            );
            out body;
            >;
            out skel qt;
            """.format(x0=x0-margin,y0=y0-margin,x1=x1+margin,y1=y1+margin)
            self.api_query_result = api.query(api_query_string)
            #proj = pyproj.Proj(init='epsg:3857') #EPSG:3857 -- WGS84 Web Mercator [used by websites]
            print("Download complete. Transforming coordinate system.")
            self.converted_ways = []
            
            for way in self.api_query_result.ways:
            #    wgs84 = pyproj.Proj(init='EPSG:4326') #WGS 84 [used by GPS satellite system]
            #    self.converted_ways.append(np.c_[pyproj.transform(wgs84,proj,path[:,0],path[:,1])])

                path = np.array([[float(n.lat),float(n.lon)] for n in way.nodes])
                self.converted_ways.append(np.c_[transformer.transform(path[:,0],path[:,1])])
        
            print("Building distance grid")
            self.compute_distancegrid()
    
    def lineseg_dists(self, p, a, b):
        """Cartesian distance from point to line segment
        From:
        https://stackoverflow.com/a/54442561/11208892        

        Args:
            - p: np.array of single point, shape (2,) or 2D array, shape (x, 2)
            - a: np.array of shape (x, 2)
            - b: np.array of shape (x, 2)
        """
        
        # normalized tangent vectors
        d_ba = b - a
        d = np.divide(d_ba, (np.hypot(d_ba[:, 0], d_ba[:, 1])
                               .reshape(-1, 1)))

        # signed parallel distance components
        # rowwise dot products of 2D vectors
        s = np.multiply(a - p, d).sum(axis=1)
        t = np.multiply(p - b, d).sum(axis=1)

        # clamped parallel distance
        h = np.maximum.reduce([s, t, np.zeros(len(s))])

        # perpendicular distance component
        # rowwise cross products of 2D vectors  
        d_pa = p - a
        c = d_pa[:, 0] * d[:, 1] - d_pa[:, 1] * d[:, 0]

        return np.hypot(h, c)   
    
    def compute_mindist(self,p):
        """
        Computes distance from point p to nearest path
        """
        mindist = np.inf
        for path in self.converted_ways:
            ls = self.lineseg_dists(p,path[0:-1,:],path[1:,:])
            d = np.min(ls)
            if d<mindist:
                mindist=d
        return mindist  
    
    def compute_distancegrid(self):
        """
        Computes and caches the distance from all the points on the grid to all the roads.
        """
        
        xs = np.arange(self.box[0,0],self.box[1,0],self.spacing)
        ys = np.arange(self.box[0,1],self.box[1,1],self.spacing)
        distancegrid = np.zeros([len(xs),len(ys)])
        #allps = []
        #allds = []
        for xi,x in enumerate(xs):
            print("%4d%% (%d/%d)      " % (int(100*(xi+1)/len(xs)),xi+1,len(xs)),end="\r")
            for yi,y in enumerate(ys):
                #allps.append([x,y])
                #allds.append(self.compute_mindist([x,y]))
                distancegrid[xi,yi] = self.compute_mindist([x,y])
        import pickle
        pickle.dump({'distancegrid':distancegrid,'converted_ways':self.converted_ways,'spacing':self.spacing,'box':self.box},open(self.cachename,'wb'))
        self.distancegrid = distancegrid
    
    def get_dist(self,p):
        """
        using the cached grid interpolate the shortest distance
        """
        index = ((p-self.box[0,:])/self.spacing).astype(int)
        ratio = ((p-self.box[0,:]) % self.spacing)/self.spacing
        #return (self.distancegrid[index[0]+1,index[1]]*ratio[0]+self.distancegrid[index[0],index[1]]*(1-ratio[0]))*(1-ratio[1])+self.distancegrid[index[0]+1,index[1]+1]*ratio[0]+self.distancegrid[index[0],index[1]+1]*(1-ratio[0])*(ratio[1])
        try:
            a0 = self.distancegrid[index[0]+1,index[1]]*ratio[0]
            a1 = self.distancegrid[index[0],index[1]]*(1-ratio[0])
            a = (a0+a1)*(1-ratio[1])
            b0 = self.distancegrid[index[0]+1,index[1]+1]*ratio[0]
            b1 = self.distancegrid[index[0],index[1]+1]*(1-ratio[0])
            b = (b0+b1)*(ratio[1])
            return a+b
        except IndexError:
            return np.nan
